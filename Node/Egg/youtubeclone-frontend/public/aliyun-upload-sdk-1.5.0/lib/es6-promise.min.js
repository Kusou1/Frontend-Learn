!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define(e) : t.ES6Promise = e() }(this, function () { 'use strict'; function t (t) { const e = typeof t; return t !== null && (e === 'object' || e === 'function') } function e (t) { return typeof t === 'function' } function n (t) { I = t } function r (t) { J = t } function o () { return function () { return process.nextTick(a) } } function i () { return typeof H !== 'undefined' ? function () { H(a) } : c() } function s () { let t = 0; const e = new V(a); const n = document.createTextNode(''); return e.observe(n, { characterData: !0 }), function () { n.data = t = ++t % 2 } } function u () { const t = new MessageChannel(); return t.port1.onmessage = a, function () { return t.port2.postMessage(0) } } function c () { const t = setTimeout; return function () { return t(a, 1) } } function a () { for (let t = 0; t < G; t += 2) { const e = $[t]; const n = $[t + 1]; e(n), $[t] = void 0, $[t + 1] = void 0 }G = 0 } function f () { try { const t = require; const e = t('vertx'); return H = e.runOnLoop || e.runOnContext, i() } catch (n) { return c() } } function l (t, e) { const n = arguments; const r = this; const o = new this.constructor(p); void 0 === o[et] && k(o); const i = r._state; return i ? !(function () { const t = n[i - 1]; J(function () { return x(i, o, t, r._result) }) }()) : E(r, o, t, e), o } function h (t) { const e = this; if (t && typeof t === 'object' && t.constructor === e) return t; const n = new e(p); return g(n, t), n } function p () {} function v () { return new TypeError('You cannot resolve a promise with itself') } function d () { return new TypeError('A promises callback cannot return that same promise.') } function _ (t) { try { return t.then } catch (e) { return it.error = e, it } } function y (t, e, n, r) { try { t.call(e, n, r) } catch (o) { return o } } function m (t, e, n) { J(function (t) { let r = !1; const o = y(n, e, function (n) { r || (r = !0, e !== n ? g(t, n) : S(t, n)) }, function (e) { r || (r = !0, j(t, e)) }, 'Settle: ' + (t._label || ' unknown promise')); !r && o && (r = !0, j(t, o)) }, t) } function b (t, e) { e._state === rt ? S(t, e._result) : e._state === ot ? j(t, e._result) : E(e, void 0, function (e) { return g(t, e) }, function (e) { return j(t, e) }) } function w (t, n, r) { n.constructor === t.constructor && r === l && n.constructor.resolve === h ? b(t, n) : r === it ? (j(t, it.error), it.error = null) : void 0 === r ? S(t, n) : e(r) ? m(t, n, r) : S(t, n) } function g (e, n) { e === n ? j(e, v()) : t(n) ? w(e, n, _(n)) : S(e, n) } function A (t) { t._onerror && t._onerror(t._result), T(t) } function S (t, e) { t._state === nt && (t._result = e, t._state = rt, t._subscribers.length !== 0 && J(T, t)) } function j (t, e) { t._state === nt && (t._state = ot, t._result = e, J(A, t)) } function E (t, e, n, r) { const o = t._subscribers; const i = o.length; t._onerror = null, o[i] = e, o[i + rt] = n, o[i + ot] = r, i === 0 && t._state && J(T, t) } function T (t) { const e = t._subscribers; const n = t._state; if (e.length !== 0) { for (let r = void 0, o = void 0, i = t._result, s = 0; s < e.length; s += 3)r = e[s], o = e[s + n], r ? x(n, r, o, i) : o(i); t._subscribers.length = 0 } } function M () { this.error = null } function P (t, e) { try { return t(e) } catch (n) { return st.error = n, st } } function x (t, n, r, o) { const i = e(r); let s = void 0; let u = void 0; let c = void 0; let a = void 0; if (i) { if (s = P(r, o), s === st ? (a = !0, u = s.error, s.error = null) : c = !0, n === s) return void j(n, d()) } else s = o, c = !0; n._state !== nt || (i && c ? g(n, s) : a ? j(n, u) : t === rt ? S(n, s) : t === ot && j(n, s)) } function C (t, e) { try { e(function (e) { g(t, e) }, function (e) { j(t, e) }) } catch (n) { j(t, n) } } function O () { return ut++ } function k (t) { t[et] = ut++, t._state = void 0, t._result = void 0, t._subscribers = [] } function Y (t, e) { this._instanceConstructor = t, this.promise = new t(p), this.promise[et] || k(this.promise), B(e) ? (this.length = e.length, this._remaining = e.length, this._result = new Array(this.length), this.length === 0 ? S(this.promise, this._result) : (this.length = this.length || 0, this._enumerate(e), this._remaining === 0 && S(this.promise, this._result))) : j(this.promise, q()) } function q () { return new Error('Array Methods must be provided an Array') } function F (t) { return new Y(this, t).promise } function D (t) { const e = this; return new e(B(t) ? function (n, r) { for (let o = t.length, i = 0; i < o; i++)e.resolve(t[i]).then(n, r) } : function (t, e) { return e(new TypeError('You must pass an array to race.')) }) } function K (t) { const e = this; const n = new e(p); return j(n, t), n } function L () { throw new TypeError('You must pass a resolver function as the first argument to the promise constructor') } function N () { throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.") } function U (t) { this[et] = O(), this._result = this._state = void 0, this._subscribers = [], p !== t && (typeof t !== 'function' && L(), this instanceof U ? C(this, t) : N()) } function W () { let t = void 0; if (typeof global !== 'undefined')t = global; else if (typeof self !== 'undefined')t = self; else try { t = Function('return this')() } catch (e) { throw new Error('polyfill failed because global object is unavailable in this environment') } const n = t.Promise; if (n) { let r = null; try { r = Object.prototype.toString.call(n.resolve()) } catch (e) {} if (r === '[object Promise]' && !n.cast) return }t.Promise = U } let z = void 0; z = Array.isArray ? Array.isArray : function (t) { return Object.prototype.toString.call(t) === '[object Array]' }; var B = z; var G = 0; var H = void 0; var I = void 0; var J = function (t, e) { $[G] = t, $[G + 1] = e, G += 2, G === 2 && (I ? I(a) : tt()) }; const Q = typeof window !== 'undefined' ? window : void 0; const R = Q || {}; var V = R.MutationObserver || R.WebKitMutationObserver; const X = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; const Z = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; var $ = new Array(1e3); var tt = void 0; tt = X ? o() : V ? s() : Z ? u() : void 0 === Q && typeof require === 'function' ? f() : c(); var et = Math.random().toString(36).substring(16); var nt = void 0; var rt = 1; var ot = 2; var it = new M(); var st = new M(); var ut = 0; return Y.prototype._enumerate = function (t) { for (let e = 0; this._state === nt && e < t.length; e++) this._eachEntry(t[e], e) }, Y.prototype._eachEntry = function (t, e) { const n = this._instanceConstructor; const r = n.resolve; if (r === h) { const o = _(t); if (o === l && t._state !== nt) this._settledAt(t._state, e, t._result); else if (typeof o !== 'function') this._remaining--, this._result[e] = t; else if (n === U) { const i = new n(p); w(i, t, o), this._willSettleAt(i, e) } else this._willSettleAt(new n(function (e) { return e(t) }), e) } else this._willSettleAt(r(t), e) }, Y.prototype._settledAt = function (t, e, n) { const r = this.promise; r._state === nt && (this._remaining--, t === ot ? j(r, n) : this._result[e] = n), this._remaining === 0 && S(r, this._result) }, Y.prototype._willSettleAt = function (t, e) { const n = this; E(t, void 0, function (t) { return n._settledAt(rt, e, t) }, function (t) { return n._settledAt(ot, e, t) }) }, U.all = F, U.race = D, U.resolve = h, U.reject = K, U._setScheduler = n, U._setAsap = r, U._asap = J, U.prototype = { constructor: U, then: l, catch: function (t) { return this.then(null, t) } }, U.polyfill = W, U.Promise = U, U.polyfill(), U }))
